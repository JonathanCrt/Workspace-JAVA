-- Exercice 1 --

	Oui ceci est très important de manière à ce que "n'importe qui" n'accède pas au champ en dehors de la classe.
	Cela permet d'encapsuler et de garantir l'intégrité des données.


-- Exercice 2 -- 

	1) Ceci permet d'utilsier le mécanisme de surchage de méthodes.
	2) Car le compilateur ne saura pas les distinguer ! La résolution de surchage donnera lieu a des méthodes  dites ambigues.
	3) Le compilateur cherche à éviter les "mauvaises surprises" 
	4)
	5) L'annotation @Override demande au compilateur devérifier qu’on redéfinit bien quelque chose.(Fournir une nouvelle définition de la
	même méthode)
	
	6) La méthode MethodResolution affiche "X.m(int)" dans la mesure ou le type de b est un Byte soit un entier défini sur 1 octet.
	on n'affichera pas "X.m(byte...)" car on ne passe pas en paramètre un tableau.
	On affichera X.m(byte...) car le compilateur détermine que la méthode la plus approprié est la première. 
	En effet, b n'est pas un entier court.

-- Exercice 3 --

-- Exercice 4 -- 

