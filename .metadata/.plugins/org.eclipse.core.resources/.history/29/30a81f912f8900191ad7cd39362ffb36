	-- Exercice 1 --

	Oui ceci est très important de manière à ce que "n'importe qui" n'accède pas au champ en dehors de la classe.
	Cela permet d'encapsuler et de garantir l'intégrité des données.


	-- Exercice 2 -- 

	1) Ceci permet d'utilsier le mécanisme de surchage de méthodes.
	2) Car le compilateur ne saura pas les distinguer ! La résolution de surchage donnera lieu a des méthodes  dites ambigues.
	3) Le compilateur vérifie que l'on a bien la bonne signature rédéfinie
	4)L'annotation @Override demande au compilateur devérifier qu’on redéfinit bien quelque chose.(Fournir une nouvelle définition de la
	même méthode)
 
	
	5) La méthode MethodResolution affiche "X.m(int)" dans la mesure ou le type de b est un Byte soit un entier défini sur 1 octet.
	on n'affichera pas "X.m(byte...)" car on ne passe pas en paramètre un tableau.
	On affichera X.m(byte...) car le compilateur détermine que la méthode la plus appropriée (la première). 
	En effet, b n'est pas un entier court.

	-- Exercice 3 --

	1) m1() : indique au développeur que cette méthode peut lever une exception, mais ceci est trop vague (manque de précision)
	   m2() : L'exception est capturée mais la m&thgode propage seulement l'exception.
	   m3() : on n'indique pas que cette méthode peut lever une exception Affiche toute la pile d'éxécution
	
	2)	on lève une exception dés que le comportement de la méthode peut nuire au bon comportement de la classe.
		


	-- Exercice 4 -- 

	1) On écrit jamais list.get(i) ! On accéde pas de façon indéxé à une java.util.List.  (compléxité)
	On pourrai utiliser un StringBuilder dans le main.
	On peut utiliser une ArrayList à la place d'une List de manière à pouvoir accéder de façon indéxé.
	stocker la taille dans une variable.
	
	2) 
		a) removeFromListIf(list, x -> x.length < 3);
	       Le type du paramètre filter est un String.
	      

		b) Iterator<String> it  = list.iterator();
		while(it.hasNext()){
			String s  = it.next();
			if(s.equals(filter)){
				it.remove();
			}
		}
		