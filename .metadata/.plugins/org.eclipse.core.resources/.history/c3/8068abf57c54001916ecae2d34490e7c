package tp3_mlv;

import java.util.ArrayList;

public class Liberte  {
	public static void main(String[] args) {
		/*
		Book b1 = new Book("Da Java Code", "Duke Brown");
	    Book b2 = b1;
	    Book b3 = new Book("Da Java Code", "Duke Brown");

	    System.out.println(b1 == b2);
	    System.out.println(b1 == b3);
	    */
	    
	    /* 
	     * 1) 
	     * 	  Le code source ci-dessus affiche : 
	     *    Affichage n°1 : true.
		 *    Affichage n°2 : false.
		 *  
		 *    En premier, true est affiché 
		 *    car la JVM à crée un seul objet 
	     *    qu'elle a affecté aux 2 variables b1 et b2 (optimisation)
	     *    b1 et b2 pointe vers le même objet
		 *  
		 * 	  En revanche, on remarque dans un second temps que false est affiché car on a 
		 *    crée une nouvelle chaine de caractére avec le mot clé new, ce qui fait que 
		 *    l'on compare deux réfèrences qui ne sont pas identiques.
		 *    Les variables b1 et b3 ne pointe donc pas vers le même objet.
		 *    
		 * 
	     * */
		    Book harry = new Book("Harry Potter et la Chambre des secrets", "J.K Rowling");
		    Book harry2 = new Book("Harry Potter et la Chambre des secrets", "J.K Rowling");
			
		    /*
		    System.out.println(Book.compareTwoString(harry.getTitle(), harry.getAuthor(), 
		    		           harry2.getTitle(), harry2.getAuthor()));
		    */
		    System.out.println(harry.compareTwoString(harry2));
	    
		/*    3) 
		 * 	  La méthode indexOf de la classe ArrayList prend en argument un objet o et 
		 * 	  renvoie l'index de la première occurrence de l'élément spécifié dans cette liste.
		 * 	  La méthode renvoie -1 si la l'élément n'est pas contenue dans la liste.
		 * 
		 *  */    
		    
		    
	    
	    /*
	        Book b1 = new Book("Da Java Code", "Duke Brown");
	        Book b2 = b1;
	        Book b3 = new Book("Da Java Code", "Duke Brown");

	        ArrayList list = new ArrayList();
	        list.add(b1);
	        System.out.println(list.indexOf(b2));
	        System.out.println(list.indexOf(b3));
	    */
	      
	    /*  4) 
	     *  La console affiche en sortie : 
	     *  Affichage n°1 : 0
	     *  Affichage n°2 : -1
	     *  
	     *  On ajouté a la liste l'objet b1
	     *  Encore une fois,  la JVM à crée un seul objet  qu'elle a affecté aux 2 variables b1 et b2 
	     *  (optimisation).
	     *  La méthode indexOf à renvoyé 0 car elle a trouvé une occurrence pour l'objet b2.
	     *  Toutefois, la liste ne contient aucune occurence pour l'objet b3, donc la méthode indexOf à renvoyé -1
	     *  
	     * */
	        
	     /* 5)
	      * La méthode indexOf appelle la méthode equals()
	      * */
	     
	      /* 8) @Override est une annotation qui demande au compilateur de vérifier qu'il existe une
				méthode à redéfinir dans le super-type
	      *  */
	        
	        Book aBook = new Book("Da Java Code", "Duke Brown");
	        Book anotherBook = new Book(null, null);
	        //Book anotherBook = new Book("", "");
	        ArrayList list = new ArrayList();
	        list.add(aBook);
	        System.out.println(list.indexOf(anotherBook));
	    	
	        /* 9)
	         *   Une exception java.lang.NullPointerException est levée.
	         *   Quand on appelle à la méthode indexOf, on fait implicitement appel aux méthodes de notre classe Book
	         *   La méthode equals va comparer un string avec une valeur nulle ce qui est impossible.
	         *   Un code doit arrêter de fonctionner et par exemple lever une exception si celui-ci est
	         *   mal utilisé par un développeur lambda dans la mesure ou il peut y avoir des conséquences systèmes,
	         *   métier qui peuvent nuire à la bonne éxécution d'un projet en environnement de production par exemple.
	         *   On doit faire en sorte que les champs de la classe Book ne sont pas null.
	         *  */
	        
	        /* 10) 
	         * 		On peut noter trois régle importante au niveau de la référence null : 
	         * 		- Une variable locale ne doit pas être null.
	         *      - Un Champ d'une classe ne doit pas être null.
	         *      - Une méthode ne doit pas retourner null.
	         *      NB : Dans le cas d'une méthode retournant un String on peut utiliser par exemple Optionnal
	         * 
	         * */
	        
	        
	        /* 11) 
	         *  java.util.Objects.requireNonNull : 
	         *  "Checks that the specified object reference is not null"
	         *  Vérifier si la référence à l'objet n'est pas nulle. 
	         *  Pour empêcher de construire un livre null il suffit d'utilise la méthode requireNonNull
	         *  au momment de la construction de l'objet Book (constructeur).
	         * 
	         * */
	}  
}
