Exemple de rédaction : 

Supposons que la valeur vaut 1 et que t1 et t2 veut exécuter “valeur +1”.
Si t2 lit la valeur de value(1) et est déschedulé
t2 lit la valeur de value (1), l’incrémente et l’écrit en mémoire. Donc value vaut ? 
Le thread est reschedulé, il incrémente la valeur (2) et l’écrit en mémoire (2). 


#################################  Exercice 0 #####################################

1) Les valeurs obtenues sont toutes différentes et supérieures
à 10_000.En mémoire, le champ value vaut 10_000
---

2) La valeur de value est 0. La thread 1 lit cette valeur et il est déschedulé. Le thread2 est schédulé et 
il termine son runnable. Donc la valeur de value est 10_000 
Le thread t1 est reschedulé et il vaut la valeur 1. 
Puis il termine son runnable et à la fin value vaut 10000.
----

3) On ne pourra jamais avoir moins de 10_000, démontrons le avec un cas possible:

--> Si t1 lit en mémoire 0, il incrémente et écrit en mémoire 3000 (par exemple).
t1 est déschédulé.
--> t2 est schédulé, lit 3000 sur le tas et incrémente jusqu'a 5000. Il est déschédulé.
--> t1 est re-schédulé. il lit 3000 en mémoire, incrémente et stocke 10_000 en mémoire.
--> t2 est re-schédulé et "écrase" et écrit 5000 en mémoire. Il incrémente en imaginant qu'il reste 8000 tour de boucles.
t2 écrit en mémoire 13_000
--> t2 est déschédulé.
--> la JVM s'arrete si tous les threads sont morts

Conclusion : 
En fin de compte, 10_000 est le minimum possible en mémoire quoi qu'il arrive(le processus arrivera à son terme). 
Si un thread est déschedulé alors qu'il a déjà lu la valeur, alors on perd la valeur de value qui à été mise à jour
(l'incrémentation n'est pas une opération atomique)



#################################  Exercice 1 #####################################
Arréter le thread à la main.
data-race = zone mémoire partagée par deux thread -> st.stop
Le main et le thread essaie d'écrire le stop.La valeur de stop ne change pas dans la boucle 
println (E/S) est une opération lente. Le JIT attend un certain nombre de boucles pour optimiser (l'optimisation coûte cher)
donc le thread s'arrêtera.
il considére la variable stop comme une variable locale (car ni getter et setter).


Pas d'optimisation par le JIT quand on a  le println.
Optimisation dès qu'on à l'instruction println



#################################  Exercice 2 #####################################








#################################  Exercice 3 #####################################






